<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Davinci Multimedia Application Interface (DMAI): Davinci Multimedia Application Interface (DMAI) 2.20.00 Build 15 User Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="user_guide">Davinci Multimedia Application Interface (DMAI) 2.20.00 Build 15 User Guide </a></h1><ul class="readonly" id="mozToc">
<li>
<a href="#mozTocId650387">1. Introduction: What is the Davinci Multimedia Application Interface (DMAI)?</a> </li>
<li>
<a href="#mozTocId467901">2. Installing DMAI</a> </li>
<li>
<a href="#mozTocId467902">3. Using DMAI</a> <ul>
<li>
<a href="#mozTocId467933">3.1 DMAI conventions</a> </li>
<li>
<a href="#mozTocId467904">3.2 Rebuilding DMAI</a> <ul>
<li>
<a href="#mozTocId467321">3.2.1 Linux and DSP/BIOS</a> </li>
<li>
<a href="#mozTocId467322">3.2.2 Windows CE</a> </li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#mozTocId46900">4. Module Overview</a> <ul>
<li>
<a href="#mozTocId46901">4.1 Graphics Buffer Module</a> </li>
<li>
<a href="#mozTocId46951">4.2 Buffer References</a> </li>
</ul>
</li>
<li>
<a href="#mozTocId467910">5. Debugging a DMAI application</a> <ul>
<li>
<a href="#mozTocId467911">5.1 Enabling DMAI trace</a> </li>
<li>
<a href="#mozTocId467913">5.2 Buffer information printing</a> </li>
</ul>
</li>
<li>
<a href="#mozTocId667910">6. DMAI Reference Applications</a> <ul>
<li>
<a href="#mozTocId667911">6.1 Building the applications</a> </li>
<li>
<a href="#mozTocId667912">6.2 Running the applications on Linux</a> </li>
<li>
<a href="#mozTocId667913">6.3 Running the applications on DSP/BIOS</a> </li>
<li>
<a href="#mozTocId667914">6.4 Running the applications on WinCE</a> </li>
<li>
<a href="#mozTocId667915">6.5 Creating your own application from the reference applications</a> </li>
</ul>
</li>
<li>
<a href="#mozTocId467903">7. Further reading</a> </li>
</ul>
<p>
<h2><a class="anchor" name="mozTocId650387"></a>1. Introduction: What is the Davinci Multimedia Application Interface (DMAI)?</h2>
<p>
DMAI is a thin utility layer on top of the operating system (Linux, WinCE or DSP/BIOS) and the Codec Engine (CE) to assist in quickly writing portable applications on a Davinci platform. DMAI is used by the DVSDK demos and should make additional demo development quicker than in previous DVSDK releases.<p>
The different DMAI modules communicate using a <a class="el" href="group__ti__sdo__dmai___buffer.html">Buffer</a> abstraction which carries not only the actual data (video, speech, audio etc.) but also meta data describing the Buffer which is used by the Codec Engine and Linux device drivers to perform operations on the data.<p>
DMAI does not <em>wrap</em> the Operating System or CE, but as the below picture shows the application can choose when to use DMAI and when to use the Operating System or Codec Engine directly:<p>
<div align="center">
<img src="dmai_block.png" alt="dmai_block.png">
<p><strong>DMAI Block Diagram</strong></p></div>
 DMAI is a functional design, meaning that the modules often describe a certain operation (frame copying using <a class="el" href="group__ti__sdo__dmai___framecopy.html">Framecopy</a>, color conversion using <a class="el" href="group__ti__sdo__dmai___ccv.html">Ccv</a>, resizing using <a class="el" href="group__ti__sdo__dmai___resize.html">Resize</a> etc.), but the module implementation may change between devices and operating systems depending on which peripheral device drivers and other local APIs are available.<p>
I.e. DMAI does <b>not</b> abstract the peripherals themselves, it abstracts the actual operations e.g. frame copying. DMAI then implements a frame copy using the peripherals and resouces at it's disposal on a particular platform (e.g. the <a class="el" href="group__ti__sdo__dmai___framecopy.html">Framecopy</a> module is currently implemented using the resizer peripheral on dm6446, but using DMA on dm355).<p>
DMAI is a collection of modules, and the application can pick and choose which modules to use. Since DMAI comes with source code, it can also be used as a reference on how to accomplish certain tasks using e.g. a certain device driver.<p>
<h2><a class="anchor" name="mozTocId467901"></a>2. Installing DMAI</h2>
<p>
If you receive DMAI as part of the DVSDK it will be extracted for you under <em>$(DVSDK_INSTALL_DIR)</em>, but if you receive it separate as an update it will be in a tar ball, i.e. <em>dmai_&lt;version&gt;.tar.gz</em>. You extract the archive using <em>tar xzf dmai_&lt;version&gt;.tar.gz</em>.<p>
You can either extract the archive to your <em>$(DVSDK_INSTALL_DIR)</em>, since each DMAI release has a unique version number the installations will not conflict. Or you can extract the archive to another directory on your system.<p>
DMAI and all of it's sample applications build using the top level <em>Rules.make</em> file, and depending on which of these two above install options you choose the behavior will be slightly different. This because the top level <em>Rules.make</em> tries to include a <em>Rules.make</em> from <b>one directory above</b> where the DVSDK would keep it's <em>Rules.make</em> if DMAI was delivered as part of a DVSDK, and if found these settings will be used instead of the local DMAI ones. This allows the DVSDK to override how DMAI is built keeping one DVSDK wide <em>Rules.make</em> file, but also allows DMAI to be built standalone without the DVSDK.<p>
After you have extracted the tar ball, the directory structure will look as follows:<p>
<div class="fragment"><pre class="fragment">
dmai_&lt;version&gt;                   // Rules.make is in this directory
|-- docs                         // Documentation files for DMAI
|-- packages                     // Your XDC path should include this dir
|   `-- ti
|       `-- sdo
|           `-- dmai             // DMAI package top level directory
|               |-- apps         // Reference applications
|               |   |
|               |   |-- audio_decode1            // audio decode using IAUDDEC1
|               |   |-- audio_decode_io          // audio decode using IAUDDEC
|               |   |-- audio_decode_io1         // audio decode using IAUDDEC1
|               |   |-- audio_encode1            // audio encode using IAUDENC1
|               |   |-- audio_encode_io1         // audio encode using IAUDENC1
|               |   |-- image_decode_io          // image decode using IIMGDEC
|               |   |-- image_decode_io1         // image decode using IIMGDEC1
|               |   |-- image_encode_io          // image encode using IIMGENC
|               |   |-- image_encode_io1         // image encode using IIMGENC1
|               |   |-- speech_decode1           // speech decode using ISPHDEC1
|               |   |-- speech_decode_io1        // speech decode using ISPHDEC1
|               |   |-- speech_encode1           // speech encode using ISPHENC1
|               |   |-- speech_encode_io1        // speech encode using ISPHENC1
|               |   |-- video_decode_io          // video decode using IVIDDEC 
|               |   |-- video_decode_io2         // video decode using IVIDDEC2
|               |   |-- video_display            // video display
|               |   |-- video_encode_io          // video encode using IVIDENC 
|               |   |-- video_encode_io1         // video encode using IVIDENC1
|               |   |-- video_encode_io_multich1 // multi channel video encode using IVIDENC1
|               |   |-- video_loopback           // video loopback no copy
|               |   |-- video_loopback_blend     // video loopback and blend
|               |   |-- video_loopback_convert   // video loopback and color convert
|               |   |-- video_loopback_copy      // video loopback copy
|               |   `-- video_loopback_resize    // video loopback and resize
|               |
|               |-- bios          // DSP/BIOS specific source
|               |
|               |-- ce            // DMAI modules assisting CE usage source
|               |
|               |-- lib           // Built DMAI libs are put here
|               |
|               |-- linux         // linux specific source
|               |   |-- dm355     // linux dm355 specific source
|               |   |-- dm365     // linux dm365 specific source
|               |   |-- dm6446    // linux dm6446 / dm357 specific source
|               |   |-- dm6467    // linux dm6467 specific source
|               |   |-- omap3530  // linux omap3530 specific source
|               |   `-- priv      // Private header files
|               |
|               |-- obj           // Compiled object files are put here
|               |-- priv          // Private header files
|               |
|               `-- wince         // WinCE specific source
|
`-- wince_pb                      // WinCE platform builder root directory
    `-- wince600                  // WinCE 6.0 platform builder support
</pre></div><p>
<h2><a class="anchor" name="mozTocId467902"></a>3. Using DMAI</h2>
<p>
DMAI depends on the <em>Codec Engine OSAL (Operating System Abstraction Layer) </em>. In order to use DMAI an application needs to have the following in it's <em>&lt;application&gt;.cfg</em> XDC configuration file (dm6467 remote linux osal configuration example):<p>
<div class="fragment"><pre class="fragment">
prog.build.platform = "ti.platforms.evmDM6467";

var os = xdc.useModule('ti.sdo.ce.osal.linux.Settings');
osalGlobal.os = os;

var ipc = xdc.useModule('ti.sdo.ce.ipc.Settings');
ipc.commType = ipc.COMM_DSPLINK;

var DMAI = xdc.loadPackage('ti.sdo.dmai');
</pre></div><p>
See the Codec Engine documentation on how to set up the osal for your platform configuration. The <em>var DMAI</em> assignment at the bottom is <b>always the same</b>, the correct library will be linked in automatically.<p>
Each DMAI module is represented with a header file residing in the top level <em>dmai</em> directory. These module interface header files should be referenced in your app relative to the <em>dmai_&lt;version&gt;/packages</em> directory, e.g. to include the Buffer module you would put the following statement in your application C source file:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="_buffer_8h.html">ti/sdo/dmai/Buffer.h</a>&gt;</span>
</pre></div><p>
You only need to include the header file of the module you want to use; if a module depends on other DMAI modules or even device drivers or Codec Engine headers, it will include them as appropriate.<p>
You should <b>never</b> reference any header files under any of the <em>priv/</em> directories, as the headers and their contents are considered internal and may change at any time and your application may break.<p>
<h3><a class="anchor" name="mozTocId467933"></a>3.1 DMAI conventions</h3>
<p>
All applications using DMAI modules need to call the <code><a class="el" href="group__ti__sdo__dmai___dmai.html#g3b4b9b9b3ebc9ce1bbf6c55179b9506a" title="Initializes DMAI. Must be called before any other DMAI module function.">Dmai_init</a></code> function which is defined in the <a class="el" href="group__ti__sdo__dmai___dmai.html">Dmai</a> module <b>before</b> using any other DMAI module API calls.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>When using Codec Engine and DMAI in the same application, it's currently necessary to call <a class="el" href="group__ti__sdo__dmai___dmai.html#g3b4b9b9b3ebc9ce1bbf6c55179b9506a" title="Initializes DMAI. Must be called before any other DMAI module function.">Dmai_init</a> <b>after</b> calling CERuntime_init.</dd></dl>
All modules with an instance object has a <code>&lt;module&gt;_create</code> API call (e.g. <code><a class="el" href="group__ti__sdo__dmai___display.html#g36c5a21769c2076331369948a854f447" title="Creates a Display driver instance.">Display_create</a></code>) to create this instance object. They also all have a <code>&lt;module&gt;_delete</code> function call to delete any resources allocated by the create call (e.g. <code><a class="el" href="group__ti__sdo__dmai___display.html#g21c7715b5d506acdc704815921e0da60" title="Deletes a Display driver instance.">Display_delete</a></code>). The create call returns a handle with which the instance will be referred to during subsequent module API calls on this instance. No module APIs can of course be called on an instance handle before it is created, and no module API:S can be called on an instance handle after it has been deleted.<p>
All modules with an instance object has an <code>&lt;module&gt;_Attrs</code> data structure (e.g. <code><a class="el" href="struct_display___attrs.html" title="Attributes used to create a Display device driver instance.">Display_Attrs</a></code>) which is passed to the <code>&lt;module&gt;_create</code> call (e.g. <code><a class="el" href="group__ti__sdo__dmai___display.html#g36c5a21769c2076331369948a854f447" title="Creates a Display driver instance.">Display_create</a></code>). This attributes structure contains configuration parameters for the module which it uses to create the instance. All <code>&lt;module&gt;_Attrs</code> structures have <b>at least</b> one set of defaults (e.g. <code><a class="el" href="group__ti__sdo__dmai___display.html#ge704d18694b4090d03e02734c5cc253b" title="Default parameters for Video window on DM6467.">Display_Attrs_DM6467_VID_DEFAULT</a></code>) . Some, like <code><a class="el" href="struct_display___attrs.html" title="Attributes used to create a Display device driver instance.">Display_Attrs</a></code>, have several sets of defaults to accomodate many typical configurations.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Exceptions to this rule are the <em>Codec Engine processing</em> modules mentioned below (<a class="el" href="group__ti__sdo__dmai___venc.html">Venc</a>, <a class="el" href="group__ti__sdo__dmai___adec.html">Adec</a> etc.) which only takes the XDM parameters as input to the <code>&lt;module&gt;_create</code> calls, but DMAI still provides defaults you should use.</dd></dl>
You should <b>always</b> set a declared attributes structure to a set of defaults. This lets the developers add more configuration options in the future without breaking your application. Typically you would set using the above mentioned examples:<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__ti__sdo__dmai___display.html#g2473380d5ed1afaa94797a3ba4847b1e" title="Handle through which to reference a Display device instance.">Display_Handle</a> hDisplay;
    <a class="code" href="struct_display___attrs.html" title="Attributes used to create a Display device driver instance.">Display_Attrs</a> dAttrs = <a class="code" href="group__ti__sdo__dmai___display.html#ge704d18694b4090d03e02734c5cc253b" title="Default parameters for Video window on DM6467.">Display_Attrs_DM6467_VID_DEFAULT</a>;

    dAttrs.<a class="code" href="struct_display___attrs.html#e2fb960b796007d9880258c56a51a303" title="Number of buffers the driver is to use, either allocated from the device driver or...">numBufs</a> = 2;

    hDisplay = <a class="code" href="group__ti__sdo__dmai___display.html#g36c5a21769c2076331369948a854f447" title="Creates a Display driver instance.">Display_create</a>(NULL, &amp;dAttrs);
</pre></div><p>
The above example will work even if more attributes are added to <code><a class="el" href="struct_display___attrs.html" title="Attributes used to create a Display device driver instance.">Display_Attrs</a></code>, since all values are assigned defaults before a value (<code><a class="el" href="struct_display___attrs.html#e2fb960b796007d9880258c56a51a303" title="Number of buffers the driver is to use, either allocated from the device driver or...">Display_Attrs.numBufs</a></code>) is explicitly modified. By keeping the default behavior the same when adding new configuration parameters, upgrade pains can be kept to a minimum as long as this convention is followed.<p>
To further future proof your application you should always use enum values and defines by their name and not their associated number or value. The value may change with new DMAI versions but the name will not (unless mentioned in the <a class="el" href="release_notes.html">Davinci Multimedia Application Interface (DMAI) $versi</a>.<p>
<h3><a class="anchor" name="mozTocId467904"></a>3.2 Rebuilding DMAI</h3>
<p>
DMAI comes with full source, partly for debugging purposes and as a reference, but also so that the user can recompile it with their own modifications.<p>
<h4><a class="anchor" name="#mozTocId467321"></a>3.2.1 Linux and DSP/BIOS</h4>
<p>
There are two ways to build DMAI, either inside or outside the DVSDK for a particular target. Inside means DMAI is extracted inside the DVSDK directory, <code>dvsdk_x_xx_xx_xx</code>, in which case DMAI will pick up the <b>DVSDK</b> <em>Rules.make</em> file and import the variables set there. For some targets it may be that DMAI needs variables set which are not set in the DVSDK Rules.make in which case they will have to be added. See the <a class="el" href="release_notes.html">Davinci Multimedia Application Interface (DMAI) $versi</a> for details for your particular target.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Make sure the PLATFORM variable is set correctly in the top level DVSDK <em>Rules.make</em> file. You can only build DMAI for one platform at a time when building inside the DVSDK.<p>
If the DVSDK already comes with a version of DMAI and you are upgrading, you will need to change the <code><b>DMAI_INSTALL_DIR</b></code> variable in the DVSDK <em>Rules.make</em> file if you want e.g. the DVSDK demos to build using the upgraded DMAI (see <a class="el" href="release_notes.html">Davinci Multimedia Application Interface (DMAI) $versi</a> for compability information for your target).</dd></dl>
To rebuild DMAI extracted outside the DVSDK, you first need to make sure the top level <b>DMAI</b> <em>Rules.make</em> points to the correct versions of components supported. Then from the top level DMAI directory, execute <code><b>make</b> to</code> get a list of available build targets. If you want to compile for e.g. dm6467 ARM Linux, you would execute <code><b>make dm6467_al</b></code>. Building outside the DVSDK allows building for multiple targets with no change to Rules.make.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>See the current <a class="el" href="release_notes.html">Davinci Multimedia Application Interface (DMAI) $versi</a> for current information on which component dependencies are required as well as which platforms and build targets are supported.</dd></dl>
DMAI can be built from different levels for a build target. From the top level the DMAI libraries and all applications will be built. From <em>packages/ti/sdo/dmai</em> only the libraries will be built. From <em>packages/ti/sdo/dmai/apps</em> only the applications will be built, and finally each application can be rebuilt individually from inside the application top level directory (e.g. <em>audio_decode_io1</em>).<p>
There are two build configurations available, <b>debug</b> and <b>release</b>. When debug is selected, no compiler optimizations are performed and assertions are enabled. This allows you to catch additional errors while developing your application. For the release configuration assertions are disabled and compiler optimizations are enabled. You can select the build configuration using the <code>BUILD_TYPE</code> flag (defaults to debug if not set). The same build configurations are available for the apps. E.g. to build dm6446 ARM Linux for release, execute:<p>
<div class="fragment"><pre class="fragment">
make BUILD_TYPE=release dm6446_al
</pre></div><p>
In addition, if you want to see how the build invokes the commands, you can enable verbose printing using the <code>VERBOSE</code> flag. E.g. for the example above:<p>
<div class="fragment"><pre class="fragment">
make BUILD_TYPE=release VERBOSE=true dm6446_al
</pre></div><p>
<h4><a class="anchor" name="#mozTocId467322"></a>3.2.2 Windows CE</h4>
<p>
There are two methods for building DMAI. Either as a WinCE platform builder subproject or from WinCE platform builder command line.<p>
<h5>3.2.2.1 Using platform builder subproject </h5>
<p>
<ul>
<li>
In Windows, add the installation directory of the XDCTOOLS to your PATH environment variable if not already done. In Windows XP, this can be done under Control Panel, System, Advanced tab, Environment variables. This is because the XDCTOOLS provide a version of the gmake utility which is needed to rebuild DMAI. </li>
<li>
Please ensure that DVSDK_INSTALL_DIR variable is set correctly in the system environment settings to point to the DVSDK installation directory </li>
<li>
Open up Visual Studio </li>
<li>
Open up your OS design in Visual Studio </li>
<li>
Select Project-&gt;Add existing subproject from the menu. Open DMAI_INSTALL_DIR/wince_pb/wince600/dmai.pbpxml, where {DMAI_INSTALL_DIR} is the DMAI installation directory. </li>
<li>
Add the DVSDK integration subproject (refer to section "Integrating the WinCE DVSDK with the WinCE Board Support Package" in the DVSDK WinCE Getting Started Guide) </li>
<li>
Set the subprojet build order to be dmai and then DVSDK integration under Project-&gt;Set Subproject Build Order </li>
<li>
Select Build-&gt;Advanced Build Commands-&gt;Build Current BSP and Subprojects. This will rebuild your BSP and the DMAI. Note that any errors when building the DMAI will not appear in the Build window. They will however be logged in the build.log file under the {DMAI_INSTALL_DIR}/wince_pb/wince600 directory. This is because the build is done using a batch file in the background. </li>
<li>
The DVSDK integration project will copy all the DMAI files to the release folder </li>
<li>
Any future rebuild of DMAI can be done using the GUI by right-clicking on the dmai subproject in the Solution Explorer and selecting “Build”. If you need the application executables to be re-exported to the Release directory, you would need to rebuild the DVSDK Integration project as well subsequently. </li>
<li>
After building your OS image, load the image onto the EVM and from the WinCE command window various dmai app commands can be run  </li>
</ul>
<p>
<h5>3.2.2.2 Using platform builder command line from DVSDK installation</h5>
<p>
<ul>
<li>
In Windows, add the installation directory of the XDCTOOLS to your PATH environment variable if not already done. In Windows XP, this can be done under Control Panel, System, Advanced tab, Environment variables. This is because the XDCTOOLS provide a version of the gmake utility which is needed to rebuild DMAI. </li>
<li>
Ensure that you have a valid WinCE DVSDK environment and that the DVSDK_INSTALL_DIR system variable points to the DVSDK installation directory </li>
<li>
Edit setpaths.bat under DVSDK_INSTALL_DIR% and make sure all paths point to the correct components including the DMAI_INSTALL_DIR that you want to compile </li>
<li>
Open up Visual Studio </li>
<li>
Open up your OS design in Visual Studio </li>
<li>
Select "Build-&gt;Open Release Directory in Build window" and open up a build window <ul>
<li>
Then run the following commands in the build window </li>
<li>
DVSDK_INSTALL_DIR\setpaths.bat </li>
<li>
cd DMAI_INSTALL_DIR% </li>
<li>
gmake clean </li>
<li>
gmake o3530_aw </li>
<li>
The "o3530_aw" is for Omap3530 ARM WinCE target. Similarly other WinCE targets will have similar syntax. Enter "gmake help" for supported targets </li>
</ul>
</li>
<li>
To export all the supported DMAI apps to the release directory, make sure EXEC_DIR in the setpaths.bat file is set to the release directory, and run the following command <ul>
<li>
gmake install </li>
</ul>
</li>
<li>
Make sure you have the appropriate binaries (cmemk.dll, dsplinkk.dll, lpmdrv.dll, cs.x64P) of the components used by DMAI apps copied to the release directory. </li>
<li>
After building your OS image, load the image onto the EVM and from the WinCE command window various dmai app commands can be run  </li>
</ul>
<p>
<h5>3.2.2.3 Using platform builder command line without DVSDK installed</h5>
<p>
<ul>
<li>
In Windows, add the installation directory of the XDCTOOLS to your PATH environment variable if not already done. In Windows XP, this can be done under Control Panel, System, Advanced tab, Environment variables. This is because the XDCTOOLS provide a version of the gmake utility which is needed to rebuild DMAI. </li>
<li>
Open up Visual Studio </li>
<li>
Open up your OS design in Visual Studio </li>
<li>
Select "Build-&gt;Open Release Directory in Build window" and open up a build window </li>
<li>
To build DMAI library and all the supported DMAI apps, <ul>
<li>
cd into the dmai installation directory DMAI_INSTALL_DIR% </li>
<li>
Edit Rules.make file under this directory and point to the appropriate DVSDK components </li>
<li>
Then run the following commands in the build window <ul>
<li>
set DVSDK_INSTALL_DIR= </li>
<li>
gmake clean </li>
<li>
gmake o3530_aw </li>
<li>
The "o3530_aw" is for Omap3530 ARM WinCE target. Similarly other WinCE targets will have similar syntax. Enter "gmake help" for supported targets </li>
</ul>
</li>
</ul>
</li>
<li>
To export all the supported DMAI apps to the release directory, make sure EXEC_DIR in the Rules.make file is set to the release directory , and run the following command <ul>
<li>
gmake install </li>
</ul>
</li>
<li>
Make sure you have the appropriate binaries (cmemk.dll, dsplinkk.dll, lpmdrv.dll, cs.x64P) of the components used by DMAI apps copied to the release directory. </li>
<li>
After building your OS image, load the image onto the EVM and from the WinCE command window various dmai app commands can be run  </li>
</ul>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>See the current <a class="el" href="release_notes.html">Davinci Multimedia Application Interface (DMAI) $versi</a> for current information on which component dependencies are required as well as which platforms and build targets are supported.</dd></dl>
DMAI can be built from different levels for a build target. From the top level the DMAI libraries and all applications will be built. From <em>packages/ti/sdo/dmai</em> only the libraries will be built. From <em>packages/ti/sdo/dmai/apps</em> only the applications will be built, and finally each application can be rebuilt individually from inside the application top level directory (e.g. <em>audio_decode_io1</em>).<p>
There are two build configurations available, <b>debug</b> and <b>release</b>. When debug is selected, no compiler optimizations are performed and assertions are enabled. This allows you to catch additional errors while developing your application. For the release configuration assertions are disabled and compiler optimizations are enabled. You can select the build configuration using the <code>BUILD_TYPE</code> flag (defaults to debug if not set). The same build configurations are available for the apps. E.g. to build omap3530 ARM WinCE for release, execute:<p>
<div class="fragment"><pre class="fragment">
gmake BUILD_TYPE=release o3530_aw
</pre></div><p>
In addition, if you want to see how the build invokes the commands, you can enable verbose printing using the <code>VERBOSE</code> flag. E.g. for the example above:<p>
<div class="fragment"><pre class="fragment">
gmake BUILD_TYPE=release VERBOSE=true o3530_aw
</pre></div><p>
<h2><a class="anchor" name="mozTocId46900"></a>4. Module Overview</h2>
<p>
DMAI consists of several modules which often are independent allowing the user to select where help is needed. E.g. one may want to handle the display device driver oneself but leave color conversion to DMAI, and as long as the <a class="el" href="group__ti__sdo__dmai___buffer.html">Buffer</a> module instances are filled in properly this is possible. Not all modules are supported on all platforms or on all OSes.<p>
There are different types of DMAI modules:<p>
<ol>
<li>
<em>Source</em> and <em>sink</em> modules (<a class="el" href="group__ti__sdo__dmai___display.html">Display</a>, <a class="el" href="group__ti__sdo__dmai___capture.html">Capture</a>, <a class="el" href="group__ti__sdo__dmai___sound.html">Sound</a> and <a class="el" href="group__ti__sdo__dmai___loader.html">Loader</a>) are used get data in or out of the system using a device driver or a file. </li>
<li>
<em>Processing</em> modules (<a class="el" href="group__ti__sdo__dmai___framecopy.html">Framecopy</a>, <a class="el" href="group__ti__sdo__dmai___ccv.html">Ccv</a>, <a class="el" href="group__ti__sdo__dmai___blend.html">Blend</a>, <a class="el" href="group__ti__sdo__dmai___smooth.html">Smooth</a>) are used to process data in the system. </li>
<li>
<em>Codec Engine processing</em> modules (<a class="el" href="group__ti__sdo__dmai___adec.html">Adec</a>, <a class="el" href="group__ti__sdo__dmai___aenc.html">Aenc</a>, <a class="el" href="group__ti__sdo__dmai___adec1.html">Adec1</a>, <a class="el" href="group__ti__sdo__dmai___aenc1.html">Aenc1</a>, <a class="el" href="group__ti__sdo__dmai___sdec.html">Sdec</a>, <a class="el" href="group__ti__sdo__dmai___senc.html">Senc</a>, <a class="el" href="group__ti__sdo__dmai___sdec1.html">Sdec1</a>, <a class="el" href="group__ti__sdo__dmai___senc1.html">Senc1</a>, <a class="el" href="group__ti__sdo__dmai___ienc.html">Ienc</a>, <a class="el" href="group__ti__sdo__dmai___idec.html">Idec</a>, <a class="el" href="group__ti__sdo__dmai___ienc1.html">Ienc1</a>, <a class="el" href="group__ti__sdo__dmai___idec1.html">Idec1</a>, <a class="el" href="group__ti__sdo__dmai___venc.html">Venc</a>, <a class="el" href="group__ti__sdo__dmai___venc1.html">Venc1</a>, <a class="el" href="group__ti__sdo__dmai___vdec.html">Vdec</a> and <a class="el" href="group__ti__sdo__dmai___vdec2.html">Vdec2</a>) are used to process data in the system using the Codec Engine VISA APIs. The VISA handle (e.g. <code>VIDDEC_Handle</code>) can be obtained from the DMAI class allowing custom codec calls to be made outside the scope of DMAI </li>
<li>
<em>Thread communication</em> modules (<a class="el" href="group__ti__sdo__dmai___pause.html">Pause</a>, <a class="el" href="group__ti__sdo__dmai___rendezvous.html">Rendezvous</a> and <a class="el" href="group__ti__sdo__dmai___fifo.html">Fifo</a>) are used to synchronize and communicate between threads. </li>
<li>
<em>Buffer management</em> modules (<a class="el" href="group__ti__sdo__dmai___buffer.html">Buffer</a>, <a class="el" href="group__ti__sdo__dmai___buffer_gfx.html">BufferGfx</a> and <a class="el" href="group__ti__sdo__dmai___buf_tab.html">BufTab</a>) are important because they represent the buffer management of DMAI and the Buffer and BufferGfx modules are the main way with which the other DMAI modules communicate with each other (and BufTab is a table of Buffer or BufferGfx instances used by DMAI modules working on full arrays of buffers such as <a class="el" href="group__ti__sdo__dmai___display.html">Display</a>, <a class="el" href="group__ti__sdo__dmai___capture.html">Capture</a> and <a class="el" href="group__ti__sdo__dmai___vdec2.html">Vdec2</a>). </li>
</ol>
<p>
There are also some miscellaneous support modules such as <a class="el" href="group__ti__sdo__dmai___video_std.html">VideoStd</a>, <a class="el" href="group__ti__sdo__dmai___color_space.html">ColorSpace</a>, <a class="el" href="group__ti__sdo__dmai___time.html">Time</a>, <a class="el" href="group__ti__sdo__dmai___ir.html">Ir</a>, <a class="el" href="group__ti__sdo__dmai___cpu.html">Cpu</a> and the <a class="el" href="group__ti__sdo__dmai___dmai.html">Dmai</a> module itself.<p>
The below diagram shows a <em>source</em> (<a class="el" href="group__ti__sdo__dmai___loader.html">Loader</a>), <em>CE processing</em> (<a class="el" href="group__ti__sdo__dmai___vdec.html">Vdec</a>) and a <em>sink</em> (<a class="el" href="group__ti__sdo__dmai___display.html">Display</a>) module, and how they communicate using a <code><a class="el" href="group__ti__sdo__dmai___buffer.html#gaed20302f51cd052c08794808526d34b" title="Handle through which to reference a Buffer instance.">Buffer_Handle</a>:</code> <p>
<div align="center">
<img src="vdec.png" alt="vdec.png">
<p><strong>Video decode</strong></p></div>
 The below diagram shows a simple audio decode similar to above. Note that the <code><a class="el" href="group__ti__sdo__dmai___sound.html#g6b8ab962f208a557aa15c0382a6b0407" title="Write a buffer to the sound output. This function can only be called if the driver...">Sound_write</a></code> synchronous call is different from the above <code><a class="el" href="group__ti__sdo__dmai___display.html#g0db8cb042b524ddfac90d247a79dc03b" title="Receive a buffer from the display device driver instance to be filled with data.">Display_get</a></code> and <code><a class="el" href="group__ti__sdo__dmai___display.html#gf03eb4f00964bfad88d339ad4c3afcc6" title="Send a buffer with data to the display device driver instance to be shown on the...">Display_put</a></code> asynchronous model:<p>
<div align="center">
<img src="adec.png" alt="adec.png">
<p><strong>Audio decode</strong></p></div>
 This diagram shows a more complex scenario where multiple <em>processing</em> modules (<a class="el" href="group__ti__sdo__dmai___ccv.html">Ccv</a>, <a class="el" href="group__ti__sdo__dmai___resize.html">Resize</a>) are chained before encoding the frame (<a class="el" href="group__ti__sdo__dmai___venc.html">Venc</a>) and writing it to a file using stdio:<p>
<div align="center">
<img src="venc.png" alt="venc.png">
<p><strong>Color conversion, Resizing and Video Encode</strong></p></div>
 When a <em>sink</em> or <em>processing</em> module receives an input Buffer it will read the current number of bytes used in the Buffer using <code><a class="el" href="group__ti__sdo__dmai___buffer.html#g65ebc3cfdfca5a03ccb8d99ea85d07f1" title="When a DMAI module has processed data and written it to a Buffer, it records the...">Buffer_getNumBytesUsed</a></code> and process this amount of bytes (as source or destination depending on which Buffer). This may or may not be the same as the size of the Buffer which can be retrieved using <code><a class="el" href="group__ti__sdo__dmai___buffer.html#gd48f431953119af116976eb3bc4df959" title="Get the size of a Buffer.">Buffer_getSize</a></code>.<p>
When a <em>source</em> or <em>processing</em> module fills an output Buffer with data it will set the number of bytes used in the Buffer using <code><a class="el" href="group__ti__sdo__dmai___buffer.html#gb0db65c5f5f6a57597986ed13ac06026" title="Set the number of bytes used in a Buffer. If you process data outside of DMAI, call...">Buffer_setNumBytesUsed</a></code> to tell the next module (or the application itself) accepting this Buffer how many bytes contain valid data. This of course needs to <b>not</b> excess the actual size of the Buffer which can be retrieved using <code><a class="el" href="group__ti__sdo__dmai___buffer.html#gd48f431953119af116976eb3bc4df959" title="Get the size of a Buffer.">Buffer_getSize</a></code>.<p>
<h3><a class="anchor" name="mozTocId46901"></a>4.1 Graphics Buffer Module</h3>
<p>
The <a class="el" href="group__ti__sdo__dmai___buffer_gfx.html">BufferGfx</a> module is a <em>super class</em> of the <a class="el" href="group__ti__sdo__dmai___buffer.html">Buffer</a> module, i.e. in an object oriented language the BufferGfx module would inherit the Buffer module. This means that each BufferGfx instance has all the properties of a Buffer instance and <b>more</b>; i.e. it has additional graphics properties (such as <code><a class="el" href="struct_buffer_gfx___dimensions.html" title="Describes the dimensions of a graphics Buffer.">BufferGfx_Dimensions</a></code> and <code><a class="el" href="group__ti__sdo__dmai___color_space.html#g1b6da3f159b6052d404f11cb010cb398" title="Color formats.">ColorSpace_Type</a></code>). This also means that any <a class="el" href="group__ti__sdo__dmai___buffer.html">Buffer</a> API calls can <b>also</b> be made on any <a class="el" href="group__ti__sdo__dmai___buffer_gfx.html">BufferGfx</a> module instance, and a BufTab operation also works on each type of Buffer. The base <a class="el" href="group__ti__sdo__dmai___buffer.html">Buffer</a> module instances are typically used for file I/O (using <a class="el" href="group__ti__sdo__dmai___loader.html">Loader</a> or stdio) or <a class="el" href="group__ti__sdo__dmai___sound.html">Sound</a> I/O. Note that both a Buffer and BufferGfx instance are referenced using a <code><a class="el" href="group__ti__sdo__dmai___buffer.html#gaed20302f51cd052c08794808526d34b" title="Handle through which to reference a Buffer instance.">Buffer_Handle</a></code>.<p>
<div align="center">
<img src="dimensions.png" alt="dimensions.png">
<p><strong>Graphics Buffer dimensions</strong></p></div>
 A BufferGfx instance has dimensions which describe the resolution (with and height) and the position on the screen as well as the line length (also called pitch, describes the number of bytes until the next line). These parameters are used by the DMAI modules to figure out which part of an image to process.<p>
You can use the <a class="el" href="group__ti__sdo__dmai___buffer_gfx.html#g378f125e5fe355ad9ae8a53e27e1d0b1" title="Get the BufferGfx_Dimensions of a BufferGfx instance. If the current dimensions are...">BufferGfx_getDimensions</a> call to get the current dimensions and <a class="el" href="group__ti__sdo__dmai___buffer_gfx.html#gf3ee6ed113ac3f27e1076c35f11903a2" title="Set the current BufferGfx_Dimensions of a BufferGfx instance.">BufferGfx_setDimensions</a> to set new dimensions in case you only want to process part of an image. You normally don't want to change the lineLength parameter.<p>
For example, if you only want to color convert part of an input image you would call <a class="el" href="group__ti__sdo__dmai___buffer_gfx.html#gf3ee6ed113ac3f27e1076c35f11903a2" title="Set the current BufferGfx_Dimensions of a BufferGfx instance.">BufferGfx_setDimensions</a> on the <b>input</b> buffer before the call to <a class="el" href="group__ti__sdo__dmai___ccv.html#g0069322dd54b888491a47f12819b892c" title="Execute a Color Conversion job.">Ccv_execute</a>. Likewise, if your output buffer is larger than the input buffer, you may want to position the result of the operation inside the output buffer by calling <a class="el" href="group__ti__sdo__dmai___buffer_gfx.html#gf3ee6ed113ac3f27e1076c35f11903a2" title="Set the current BufferGfx_Dimensions of a BufferGfx instance.">BufferGfx_setDimensions</a> on the <b>output</b> buffer before calling <a class="el" href="group__ti__sdo__dmai___ccv.html#g0069322dd54b888491a47f12819b892c" title="Execute a Color Conversion job.">Ccv_execute</a>.<p>
All <a class="el" href="group__ti__sdo__dmai___buffer_gfx.html">BufferGfx</a> instances get a dimension when they are created, and these original dimensions cannot be changed. Instead, a subwindow is recorded when <a class="el" href="group__ti__sdo__dmai___buffer_gfx.html#gf3ee6ed113ac3f27e1076c35f11903a2" title="Set the current BufferGfx_Dimensions of a BufferGfx instance.">BufferGfx_setDimensions</a> is called, which will be returned by subsequent <a class="el" href="group__ti__sdo__dmai___buffer_gfx.html#g378f125e5fe355ad9ae8a53e27e1d0b1" title="Get the BufferGfx_Dimensions of a BufferGfx instance. If the current dimensions are...">BufferGfx_getDimensions</a> calls. If you want to restore the original dimensions you can use the <a class="el" href="group__ti__sdo__dmai___buffer_gfx.html#ge5fb9c8b3394eb622b6c64e10bafbdea" title="Reset the dimensions to the original create time dimensions.">BufferGfx_resetDimensions</a> call.<p>
It's good practice to always set (or reset) the dimensions of a graphics buffer before calling a graphics DMAI module function on a buffer. This way you avoid picking up unwanted dimensions from other processing calls in your application.<p>
<b>Note!</b> Due to the design of XDM not all DMAI modules wrapping Codec Engine VISA modules set the lineLength correctly, since the frame pitch cannot be set on a per buffer basis. This can normally be set in the dynamic parameters of the XDM interface instead, make sure the codec supports this parameter.<p>
<h3><a class="anchor" name="mozTocId46951"></a>4.2 Buffer References</h3>
<p>
A feature added in DMAI 1.16 is support for Buffer References. Before when a <a class="el" href="group__ti__sdo__dmai___buffer.html">Buffer</a> instance was created, it always allocated a buffer in memory for the Buffer instance, but there are cases when this is not desired.<p>
E.g. if a buffer was allocated using a device driver or elsewhere in the system and this buffer is to be used by DMAI, a physical buffer should not be allocated. For this and other use cases, the Buffer Reference concept was introduced.<p>
The <a class="el" href="struct_buffer___attrs.html#a12c80fdce31ef7a07c19b8b79cb90a9" title="If this is set to true no buffer will be allocated, instead the resulting Buffer_Handle...">Buffer_Attrs.reference</a> flag indicates whether a buffer is a reference or not. If set to TRUE, no memory will be allocated for the Buffer instance. In addition, the API calls <a class="el" href="group__ti__sdo__dmai___buffer.html#g6fda7fee81d1dbd5cd236268d715deed" title="Set the User pointer for a Buffer reference.">Buffer_setUserPtr</a> and <a class="el" href="group__ti__sdo__dmai___buffer.html#ge171e463362b7d82d798ceb13a0e3870" title="Set the size of a Buffer reference.">Buffer_setSize</a> API calls were added to manipulate a Buffer Reference (note that these API calls do not work on a non-reference Buffer instance). The <a class="el" href="group__ti__sdo__dmai___buffer.html#gcecebb9f68439ccf6bc62496163f3088" title="Investigate whether a Buffer instance is a reference or not.">Buffer_isReference</a> call can be used on a Buffer instance to determine if it's a reference or not.<p>
<div align="center">
<img src="dmai_buffer_references.png" alt="dmai_buffer_references.png">
<p><strong>DMAI Buffer Reference</strong></p></div>
 A Buffer Reference can be used with the DMAI modules just like a non-reference Buffer instance. Note that when <a class="el" href="group__ti__sdo__dmai___buffer.html#g4108b1359e8cc6b7ecc60f49c7c73d85" title="Deletes and frees a contiguous Buffer.">Buffer_delete()</a> is called on a reference, it will not try to deallocate the existing data memory.<p>
Here's an example:<p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__ti__sdo__dmai___buffer.html#gaed20302f51cd052c08794808526d34b" title="Handle through which to reference a Buffer instance.">Buffer_Handle</a> buffer;
<a class="code" href="group__ti__sdo__dmai___buffer.html#gaed20302f51cd052c08794808526d34b" title="Handle through which to reference a Buffer instance.">Buffer_Handle</a> copyBuffer;
<a class="code" href="struct_buffer___attrs.html" title="Attributes used when creating a Buffer instance.">Buffer_Attrs</a>  attrs;
 
attrs = <a class="code" href="group__ti__sdo__dmai___buffer.html#g95800678a1e1657e5888dea75b6050f5" title="The default parameters when creating a Buffer.">Buffer_Attrs_DEFAULT</a>;
 
buffer = <a class="code" href="group__ti__sdo__dmai___buffer.html#g2113d5b307f2c5b6101e23072861bcd8" title="Creates and allocates a contiguous Buffer.">Buffer_create</a>(1024, &amp;attrs);    <span class="comment">// creates a buffer object and an underlying data buffer of size 1024</span>
 
attrs.<a class="code" href="struct_buffer___attrs.html#a12c80fdce31ef7a07c19b8b79cb90a9" title="If this is set to true no buffer will be allocated, instead the resulting Buffer_Handle...">reference</a> = TRUE;
copyBuffer = <a class="code" href="group__ti__sdo__dmai___buffer.html#g2113d5b307f2c5b6101e23072861bcd8" title="Creates and allocates a contiguous Buffer.">Buffer_create</a>(<a class="code" href="group__ti__sdo__dmai___buffer.html#gd48f431953119af116976eb3bc4df959" title="Get the size of a Buffer.">Buffer_getSize</a>(buffer), &amp;attrs);    <span class="comment">// creates a Buffer reference for a memory area of size 1024</span>
 
<a class="code" href="group__ti__sdo__dmai___buffer.html#g6fda7fee81d1dbd5cd236268d715deed" title="Set the User pointer for a Buffer reference.">Buffer_setUserPtr</a>(copyBuffer, <a class="code" href="group__ti__sdo__dmai___buffer.html#g33db418617064b9d24ba1859d0b4b41c" title="Get the user pointer of the Buffer. This pointer can be used to access the Buffer...">Buffer_getUserPtr</a>(buffer));      <span class="comment">// makes this reference point to the existing 1024-byte data buffer</span>
<span class="comment">//Buffer_setSize(copyBuffer, Buffer_getSize(buffer));          // can change the size to match the existing buffer if necessary</span>
 
<a class="code" href="group__ti__sdo__dmai___buffer.html#g4108b1359e8cc6b7ecc60f49c7c73d85" title="Deletes and frees a contiguous Buffer.">Buffer_delete</a>(copyBuffer);               <span class="comment">// deletes the reference. Will NOT deallocate the data buffer</span>
<a class="code" href="group__ti__sdo__dmai___buffer.html#g4108b1359e8cc6b7ecc60f49c7c73d85" title="Deletes and frees a contiguous Buffer.">Buffer_delete</a>(buffer);                   <span class="comment">// deletes the original buffer object and deallocate its underlying storage.</span>
</pre></div><p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>For an advanced use case of using a Buffer Reference to implement a ring buffer, see the <a class="el" href="group__ti__sdo__dmai___loader.html">Loader</a> module.</dd></dl>
<h2><a class="anchor" name="mozTocId467910"></a>5. Debugging a DMAI application</h2>
<p>
This section discusses some ways of obtaining more information from your DMAI based application.<p>
<h3><a class="anchor" name="mozTocId467911"></a>5.1 Enabling DMAI trace</h3>
<p>
The DMAI modules have trace built in which can be enabled on Linux using the <code>DMAI_DEBUG</code> environment variable. Setting it to '1' prints errors and warnings, while setting it to '2' prints errors, warnings and debug messages. If you have a target application <em>myapp</em> which uses DMAI you can set this environment variable for just one invocation of the command by executing the following on the <b>target</b> in the bash shell:<p>
<div class="fragment"><pre class="fragment">
&gt; DMAI_DEBUG=2 ./myapp
</pre></div><p>
This will send the DMAI trace output to stdout.<p>
<ul>
<li>
DMAI_DEBUG=0 disables DMAI trace, even if it is set by Dmai_setLogLevel in the application itself. </li>
<li>
DMAI_DEBUG=1: errors and warnings </li>
<li>
DMAI_DEBUG=2: all messages </li>
</ul>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>CE_DEBUG can be used to independently set the debug level for the Codec Engine. It does not affect the debug level for DMAI.<p>
This does <b>not</b> require a recompile of DMAI as trace is always built in.</dd></dl>
<h3><a class="anchor" name="mozTocId467913"></a>5.2 Buffer information printing</h3>
<p>
There are two DMAI API calls added just to print out information about <a class="el" href="group__ti__sdo__dmai___buffer.html">Buffer</a> instances: <code><a class="el" href="group__ti__sdo__dmai___buffer.html#gdbc90ffe4095b9eda5ee5bebf25e52f7" title="Prints information about a buffer.">Buffer_print</a></code> is on a per Buffer instance basis and <code><a class="el" href="group__ti__sdo__dmai___buf_tab.html#gb6980e59dddd2457cc649f03fa166c51" title="Print information about the buffers in the BufTab.">BufTab_print</a></code> will print informations for all Buffers in a <a class="el" href="group__ti__sdo__dmai___buf_tab.html">BufTab</a>.<p>
These functions are quite useful for tracking changes to Buffer state as a Buffer transitions through a system.<p>
<h2><a class="anchor" name="mozTocId667910"></a>6. DMAI Reference Applications</h2>
<p>
The <code><b>packages/ti/sdo/dmai/apps</b></code> directory contains reference applications that use DMAI.<p>
The header of each applications's main.c source file contains a brief description of what the application does.<p>
<h3><a class="anchor" name="mozTocId667911"></a>6.1 Building the applications</h3>
<p>
Each application uses the XDC configuro tool for configuration of the Codec Engine, codecs, and to load support for DMAI. Loading support for DMAI means querying the DMAI XDC package for the appropriate library that should be linked in by the application to provide the DMAI API.<p>
One or more <code>*.cfg</code> files are present in each application directory to describe the corresponding application's configuration. The application Makefile will look for a <code></code>[application]_[device].cfg file, and if it exists the application will be built for this device. For example, the Makefile will find <code>video_display_dm355.cfg</code> and determine that this application should be built for the <em>dm355</em> target device.<p>
When a <code>*.cfg</code> file is not available for a specific device, the application was not validated on that device. In order to run the application on that device, a new <code>*.cfg</code> should be created by copying and updating the <code>*_[device].cfg</code> from a different application (for the same device). Make sure that the parameters passed in <code>Engine.createFromServer()</code> or <code>Engine.create()</code> are correctly updated.<p>
All applications share the same Makefile in the <code>packages/ti/sdo/dmai/apps/Makefile.app</code> file, and common configuration is kept in <code>packages/ti/sdo/dmai/apps/app_common.cfg</code>.<p>
An application will try to access the codecs referenced in the <code></code>[application]_[device].cfg file along the paths defined by the <code>XDC_PATH</code> environment variable. If these codecs are not found a warning will be issued, but the building process will not fail. Most of the applications use codecs which are part of a DVSDK, however some may try to use codecs which are not included in a DVSDK.<p>
Executing <code>make</code> lists the available build targets.<p>
Then, <code>make [device target]</code> must be executed to build for a specific target, e.g. <code>make dm6467_al</code> to build for ARM Linux on the dm6467 device and <code>make dm6446_db</code> to build for DSP/BIOS on the dm6446 device.<p>
Note! If an application fails to build because the configuration step cannot find the <code>ti.sdo.dmai</code> package, make sure you have built DMAI itself for the build target.<p>
<h3><a class="anchor" name="mozTocId667912"></a>6.2 Running the applications on Linux</h3>
<p>
Before running the application in a Linux environment, the necessary kernel modules must be loaded using the <code>loadmodules.sh</code> script provided with the DVSDK.<p>
The application executable must be loaded to the target. This can be achieved by manual copy or by executing <code>make install</code> in the application directory.<p>
If the application is using remote codecs the codec server files (ends with <code></code>.x64P) must be loaded to the same directory as the application executables.<p>
The usage for each application will be provided by invoking the <code>-h</code> command-line <a class="el" href="structoption.html">option</a>. Required parameters must be passed to the application.<p>
Some applications (especially the ones using peripherals) have platform specific constraints. Read <code></code>[application]/linux/main.c for more information.<p>
DMAI debug trace can be enabled by setting the DMAI_DEBUG environment variable in Linux. Setting it to 1 corresponds to errors and warnings only, 2 corresponds to all trace (see <a href="#mozTocId467911">5.1 Enabling DMAI trace</a>).<p>
<h3><a class="anchor" name="mozTocId667913"></a>6.3 Running the applications on DSP/BIOS</h3>
<p>
In order to run the DSP/BIOS applications, CCS 3.3 and a JTAG emulator are required.<p>
In order to build the application for a specific platform, the [application]/bios directory must include a [application]_[device].cfg and a [application]_[device].tcf. For example, in order to run the audio_decode_io1 DSP/BIOS application on the dm6467 platform, the audio_decode_io1/bios directory must include the files audio_decode_io1_dm6467.cfg and audio_decode_io1_dm6467.tcf. If these files are not included, these files can be created by copying and renaming files existing for a different platform. After re-naming the files, the .tcf file does not require any changes but the .cfg file must be updated to reflect the codec package used. The names used for the engine and the codec must be used as arguments in the args.c file.<p>
When using CCS, each platform requires specific GEL files which set up the memory map. CCS 3.3.81.5 includes the necessary GEL files. If the CCS used does not include the GEL files, download them from <a href="http://support.spectrumdigital.com/index.html?osCsid=53e727c80ba4c88096dd0f79f9a1c780">Spectrum Digital</a>.<p>
In order to connect the board to CCS an emulator is required. The emulator drivers must be installed before connecting the board to CCS.<p>
Before using CCS, launch CCS Setup and select the Factory Board required by the platform and the emulator used. Right-click on the Processor and select Properties. If the GEL file is not associated with that processor, load the GEL file. After completing the Setup, launch CCS. On heterogenous platforms with ARM and DSP, you need to bring the DSP out of reset before you can connect to it via CCS:<p>
<b>DM6467 EVM</b><p>
Before powering ON the board set SW3 Boot Mode Configuration switch to the No Boot position: SW3[4:1]=1111. <ol>
<li>
In the Parallel Debug Manager, right-click on the ICEPICK and click Connect Device </li>
<li>
Right-click on the ARM926 and select Open. This will open a CCS control window to the ARM. Connect to the ARM by selecting Debug-&gt;Connect from the menu. </li>
<li>
Select GEL-&gt;Davinci HD DSP-&gt;DSP_Boot_from_DDR2 to release the DSP from reset. </li>
<li>
Disconnect from the ARM by hitting Alt-C (Debug Disconnect) </li>
<li>
Open a control window to the DSP from the Parallel Debug Manager by right clicking on C6400PLUS and selecting Open. </li>
<li>
Connect to DSP - Alt-C (Debug Connect) </li>
<li>
In CCS, after connecting to the DSP, do the following: <ol>
<li>
Select File-&gt;Load GEL to open the GEL file dmai.gel in the apps/ directory. </li>
<li>
Load the executable of your choice. </li>
<li>
Select Debug-&gt;Go Main to go to main(). </li>
<li>
Select GEL-&gt;Dmai-&gt;Setup_Rtdx_Cio to setup CIO to use RTDX if you intend to use RTDX. (see below for more information about RTDX). </li>
<li>
Optionally select GEL-&gt;Dmai-&gt;Set_debugLogLevel_1 or GEL-&gt;Dmai-&gt;Set_debugLogLevel_2 to set the debug level of your choice, if you want debug trace to appear on stdout. 1 corresponds to errors and warnings only, 2 corresponds to all trace. Note that you MUST do this prior to the code running <a class="el" href="group__ti__sdo__dmai___dmai.html#g3b4b9b9b3ebc9ce1bbf6c55179b9506a" title="Initializes DMAI. Must be called before any other DMAI module function.">Dmai_init()</a>. </li>
<li>
Hit F5 to run the application. Note that in DSP/BIOS, the application does not automatically halt when it reaches the end. </li>
</ol>
</li>
</ol>
<p>
<b>DM6446 EVM</b><p>
Before powering ON the board set S3 Configuration switch to 0011111110. The steps for the DM6446 EVM are similar to the steps described above for DM6467 EVM: Connect to ARM, Release the DSP, Connect to DSP.<p>
<b>General</b><p>
If you are running video applications that do file I/O (ie. all applications with names that end with <em>_io</em>), it is strongly recommended to download and install RTDX 2.10 or above from <a href="https://www-a.ti.com/downloads/sds_support/targetcontent/rtdx/index.html">here</a>.<p>
This enhances CIO by making it up to 60 times faster. After installing it, you should perform the following:<p>
<ol>
<li>
You may need to replace RtdxConfig.ocx in CCS 3.3 (<em>C:/CCSTUDIO_V3</em>.3/plugins/rtdx) with the one provided in the RTDX installation. Make sure you move the original file outside of its folder, otherwise CCS will still be able to find it despite you renaming it. </li>
<li>
In CCSetup, change the emulator TCLK speed by right-clicking on your emulator on the System Configuration pane, choose properties, and change JTAG TCLK Frequency to "Automatic with legacy 10.368MHz limit" </li>
<li>
Enable CIO to use RTDX by uncommenting sections of the code that does this in the .cfg and .tcf files of the application under the <b></b>[application]/bios/ directory. Then rebuild the application. </li>
</ol>
<p>
In addition to the DMAI debug trace, it is also possible to enable in CCS the Codec Engine debug trace. See more details here <a href="http://wiki.davincidsp.com/index.php?title=Codec_Engine_FAQ">Codec Engine FAQ</a>.<p>
<h3><a class="anchor" name="mozTocId667914"></a>6.4 Running the applications on WinCE</h3>
<p>
The steps outlined in the WinCE build section will copy all the supported DMAI applications to WinCE release dir. Follow the BSP guidelines for loading the WinCE image to the platform. These sample applications use file-based input and output to perform encode or decode. Issue the desired commands shown below in the target control prompts provided in Visual Studio 2005 Professional Edition (with Windows Embedded CE with Platform Builder support installed). The test commands assume that media files are located in the _FLATRELEASEDIR% directory. In examples given below, this is /Release/data. Similarly output files are expected to be located in the _FLATRELEASEDIR% directory, which may be /Release/results. The output directory is assumed to exist for the output files to be created.<p>
<b>Test commands for DMAI decode applications</b><p>
These examples are for Omap3530. Each processor type will have its similar executables containing processor name and the procedure to test will be similar. Certain features defined below may not be applicable to other chips. The following should be used as reference only.<p>
To perform an H.264 decode of 50 frames of an H.264 elementary stream into UYVY packed RAW frames: <div class="fragment"><pre class="fragment">
s video_decode_io2_omap3530 -c h264dec -i /Release/data/davincieffect_ntsc.264 -o /Release/results/davincieffect_ntsc.264.yuv -n 50 
</pre></div><p>
To perform an AAC decode of 200 frames of an AAC elementary stream into a PCM audio file: <div class="fragment"><pre class="fragment">
s audio_decode_io1_omap3530 -c aachedec -i /Release/data/davincieffect.aac -o /Release/results/davincieffect.aac.pcm -n 200 
</pre></div><p>
To perform a JPEG decode of a JPEG image into a UYVY Packed RAW frame: <div class="fragment"><pre class="fragment">
s image_decode_io1_omap3530 -c jpegdec -i /Release/data/fruitbasket_352x288_420p.jpg -o /Release/results/fruitbasket_352x288_420p.uyvy
</pre></div><p>
To perform an MPEG2 decode of 50 frames of an MPEG2 elementary stream into UYVY packed RAW frames: <div class="fragment"><pre class="fragment">
s video_decode_io2_omap3530 -c mpeg2dec -i /Release/data/davincieffect_cif.m2v -o /Release/results/davincieffect_cif.m2v.yuv -n 50 
</pre></div><p>
To perform a speech decode of 1000 speech frames from g.711 alaw format to 16 bit linear PCM format: <div class="fragment"><pre class="fragment">
s speech_decode_io1_omap3530 -c g711dec -i /Release/data/sounds/davincieffect.g711 -o /Release/results/sounds/davincieffect.pcm --compandinglaw alaw -n 1000
</pre></div><p>
<b> Test commands for DMAI encode applications </b><p>
To perform a JPEG encode of a UYVY packed RAW frame of resolution 720x480 into a JPEG image: <div class="fragment"><pre class="fragment">
s image_encode_io1_omap3530 -c jpegenc -i /Release/data/fruitbasket_352x288_420p.uyvy -o /Release/results/fruitbasket_352x288_420p.jpg -r 352x288 --iColorSpace 3
</pre></div><p>
To perform an H.264 encode of 50 UYVY packed RAW frames of resolution 720x480 into an H.264 elementary stream at a bitrate of 1 Mbps: <div class="fragment"><pre class="fragment">
s video_encode_io1_omap3530 -c h264enc -i /Release/data/davincieffect_ntsc.264.uyvy -o /Release/results/davincieffect_ntsc.264 -r 720x480 -b 1000000 -n 50 
</pre></div><p>
To perform a speech encode of 1000 speech frames from 16bit linear PCM format to g.711 alaw format: <div class="fragment"><pre class="fragment">
s speech_encode_io1_omap3530 -c g711enc -i /Release/data/sounds/davincieffect.pcm -o /Release/results/sounds/davincieffect.alaw --compandinglaw alaw -n 1000
</pre></div><p>
<h3><a class="anchor" name="mozTocId667915"></a>6.5 Creating your own application from the reference applications</h3>
<p>
If you want to create your own application using these applications as a reference, and want to put them in your own directory outside the DMAI directory structure, make sure the <code>DMAI_INSTALL_DIR</code> variable is set correctly at the top of your Makefile. The DMAI application Makefile uses the top level <code>Rules.make</code> to find the components it needs to build the application, and setting the <code>DMAI_INSTALL_DIR</code> variable allows the Makefile to find this file.<p>
<h2><a class="anchor" name="mozTocId467903"></a>7. Further reading</h2>
<p>
<ul>
<li>
Codec Engine Application Developer User's Guide (<em>sprue67d</em>). </li>
</ul>
</div>
<hr size="1"><small>
Copyright  2011, Texas Instruments Incorporated</small>
</body>
</html>
