<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Davinci Multimedia Application Interface (DMAI): Capture_Attrs Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Capture_Attrs Struct Reference<br>
<small>
[<a class="el" href="group__ti__sdo__dmai___capture.html">Capture</a>]</small>
</h1><!-- doxytag: class="Capture_Attrs" -->Attributes used to create a Capture device driver instance.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="_capture_8h-source.html">Capture.h</a>&gt;</code>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_capture___attrs.html#1a90830ea3624512ddf062106b71476a">numBufs</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of buffers the driver is to use, either allocated from the device driver or the supplied <a class="el" href="group__ti__sdo__dmai___buf_tab.html#g2200af650b24d3ef473a4016c89dccfc" title="Handle through which to reference a BufTab.">BufTab_Handle</a>.  <a href="#1a90830ea3624512ddf062106b71476a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__ti__sdo__dmai___capture.html#g0396f0332ca661d1894cc2b68a514114">Capture_Input</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_capture___attrs.html#86073ec71e2dd56b968c7216a0e5e270">videoInput</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Which video input to use.  <a href="#86073ec71e2dd56b968c7216a0e5e270"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_capture___attrs.html#71a5350fa3a9f11068f3e789283683e7">cropWidth</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Width of image to crop (if supported by H/W, otherwise ignored). If set to a negative value, no cropping will be used. This value needs to be even.  <a href="#71a5350fa3a9f11068f3e789283683e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_capture___attrs.html#5a7131c20f4f455ef0ff8203c5b9bbef">cropHeight</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Height of image to crop (if supported by H/W, otherwise ignored). If set to a negative value, no cropping will be used.  <a href="#5a7131c20f4f455ef0ff8203c5b9bbef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_capture___attrs.html#0038333e84fdd6769219b427687b46ae">cropX</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">X pos of image to crop (if supported by H/W, otherwise ignored). If set to a negative value, no cropping will be used.  <a href="#0038333e84fdd6769219b427687b46ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_capture___attrs.html#5e5bda0aeda14a5e9b26774ed9117c98">cropY</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Y pos of image to crop (if supported by H/W, otherwise ignored). If set to a negative value, no cropping will be used.  <a href="#5e5bda0aeda14a5e9b26774ed9117c98"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_capture___attrs.html#261c339bfa8f67e761ff171fbcae2d34">captureDevice</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Name of the Linux v4l2 capture device to use.  <a href="#261c339bfa8f67e761ff171fbcae2d34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_capture___attrs.html#536ef60eb3eeb0c059b2da54127d0fa8">smoothPad</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When using the dm6446 resizer to <a class="el" href="group__ti__sdo__dmai___smooth.html">Smooth</a> the captured images, 2 extra rows at the top and 4 extra rows at the bottom needs to be captured (if possible).  <a href="#536ef60eb3eeb0c059b2da54127d0fa8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__ti__sdo__dmai___video_std.html#g516f1c2c17e3cf9bef416a6bbb8a9289">VideoStd_Type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_capture___attrs.html#75b44be66cfe05345a9aca3bfc4d076d">videoStd</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">To force a certain video standard without auto detection, set this variable to something other than <a class="el" href="group__ti__sdo__dmai___video_std.html#gg516f1c2c17e3cf9bef416a6bbb8a928967c7473e7783791683178476d20a24c4">VideoStd_AUTO</a>.  <a href="#75b44be66cfe05345a9aca3bfc4d076d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_capture___attrs.html#4eb86cd8b67b2ba4394e99e2f84109de">decoderIdx</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">To force a certain decoder on dm6467 instead of auto detecting which decoder supports your <a class="el" href="struct_capture___attrs.html#86073ec71e2dd56b968c7216a0e5e270" title="Which video input to use.">Capture_Attrs.videoInput</a>, set this to a value &gt; -1. See the VPIF device driver guide on which values apply (VIDIOC_S_STD ioctl). This is useful when auto detection doesn't work, e.g. when two EVM:s are interconnected.  <a href="#4eb86cd8b67b2ba4394e99e2f84109de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__ti__sdo__dmai___color_space.html#g1b6da3f159b6052d404f11cb010cb398">ColorSpace_Type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_capture___attrs.html#8889c59f3590235ca8a83c909d2fab8c">colorSpace</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output color format.  <a href="#8889c59f3590235ca8a83c909d2fab8c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_buffer_gfx___dimensions.html">BufferGfx_Dimensions</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_capture___attrs.html#bca75df189e0cdc448c9f89bd02aa74b">captureDimension</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Capture image size.  <a href="#bca75df189e0cdc448c9f89bd02aa74b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_capture___attrs.html#78b419cc9d5e519b3c2c63af7a79ca14">onTheFly</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the resizer/previewer to "on the fly mode". In this mode the capture device is chained with previewer/resizer to resize and do chroma conversion on the fly.  <a href="#78b419cc9d5e519b3c2c63af7a79ca14"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Attributes used to create a Capture device driver instance. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__ti__sdo__dmai___capture.html#g01c49208bc265dec1ae0f725daf7f942" title="Default attributes for video window 0 on dm6446 and dm355.">Capture_Attrs_DM6446_DM355_DEFAULT</a> <p>
<a class="el" href="group__ti__sdo__dmai___capture.html#gf5d360bc4f62956c39535cba641f83a0" title="Default attributes for video window 0 on dm6467.">Capture_Attrs_DM6467_DEFAULT</a> </dd></dl>
<hr><h2>Field Documentation</h2>
<a class="anchor" name="1a90830ea3624512ddf062106b71476a"></a><!-- doxytag: member="Capture_Attrs::numBufs" ref="1a90830ea3624512ddf062106b71476a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int <a class="el" href="struct_capture___attrs.html#1a90830ea3624512ddf062106b71476a">Capture_Attrs::numBufs</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Number of buffers the driver is to use, either allocated from the device driver or the supplied <a class="el" href="group__ti__sdo__dmai___buf_tab.html#g2200af650b24d3ef473a4016c89dccfc" title="Handle through which to reference a BufTab.">BufTab_Handle</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="86073ec71e2dd56b968c7216a0e5e270"></a><!-- doxytag: member="Capture_Attrs::videoInput" ref="86073ec71e2dd56b968c7216a0e5e270" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ti__sdo__dmai___capture.html#g0396f0332ca661d1894cc2b68a514114">Capture_Input</a> <a class="el" href="struct_capture___attrs.html#86073ec71e2dd56b968c7216a0e5e270">Capture_Attrs::videoInput</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Which video input to use. 
<p>

</div>
</div><p>
<a class="anchor" name="71a5350fa3a9f11068f3e789283683e7"></a><!-- doxytag: member="Capture_Attrs::cropWidth" ref="71a5350fa3a9f11068f3e789283683e7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int32 <a class="el" href="struct_capture___attrs.html#71a5350fa3a9f11068f3e789283683e7">Capture_Attrs::cropWidth</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Width of image to crop (if supported by H/W, otherwise ignored). If set to a negative value, no cropping will be used. This value needs to be even. 
<p>

</div>
</div><p>
<a class="anchor" name="5a7131c20f4f455ef0ff8203c5b9bbef"></a><!-- doxytag: member="Capture_Attrs::cropHeight" ref="5a7131c20f4f455ef0ff8203c5b9bbef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int32 <a class="el" href="struct_capture___attrs.html#5a7131c20f4f455ef0ff8203c5b9bbef">Capture_Attrs::cropHeight</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Height of image to crop (if supported by H/W, otherwise ignored). If set to a negative value, no cropping will be used. 
<p>

</div>
</div><p>
<a class="anchor" name="0038333e84fdd6769219b427687b46ae"></a><!-- doxytag: member="Capture_Attrs::cropX" ref="0038333e84fdd6769219b427687b46ae" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int32 <a class="el" href="struct_capture___attrs.html#0038333e84fdd6769219b427687b46ae">Capture_Attrs::cropX</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
X pos of image to crop (if supported by H/W, otherwise ignored). If set to a negative value, no cropping will be used. 
<p>

</div>
</div><p>
<a class="anchor" name="5e5bda0aeda14a5e9b26774ed9117c98"></a><!-- doxytag: member="Capture_Attrs::cropY" ref="5e5bda0aeda14a5e9b26774ed9117c98" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int32 <a class="el" href="struct_capture___attrs.html#5e5bda0aeda14a5e9b26774ed9117c98">Capture_Attrs::cropY</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Y pos of image to crop (if supported by H/W, otherwise ignored). If set to a negative value, no cropping will be used. 
<p>

</div>
</div><p>
<a class="anchor" name="261c339bfa8f67e761ff171fbcae2d34"></a><!-- doxytag: member="Capture_Attrs::captureDevice" ref="261c339bfa8f67e761ff171fbcae2d34" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Char* <a class="el" href="struct_capture___attrs.html#261c339bfa8f67e761ff171fbcae2d34">Capture_Attrs::captureDevice</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Name of the Linux v4l2 capture device to use. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Only applicable on Linux. </dd></dl>

</div>
</div><p>
<a class="anchor" name="536ef60eb3eeb0c059b2da54127d0fa8"></a><!-- doxytag: member="Capture_Attrs::smoothPad" ref="536ef60eb3eeb0c059b2da54127d0fa8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool <a class="el" href="struct_capture___attrs.html#536ef60eb3eeb0c059b2da54127d0fa8">Capture_Attrs::smoothPad</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When using the dm6446 resizer to <a class="el" href="group__ti__sdo__dmai___smooth.html">Smooth</a> the captured images, 2 extra rows at the top and 4 extra rows at the bottom needs to be captured (if possible). 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Only applicable for dm6446 / dm357 Linux. </dd></dl>

</div>
</div><p>
<a class="anchor" name="75b44be66cfe05345a9aca3bfc4d076d"></a><!-- doxytag: member="Capture_Attrs::videoStd" ref="75b44be66cfe05345a9aca3bfc4d076d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ti__sdo__dmai___video_std.html#g516f1c2c17e3cf9bef416a6bbb8a9289">VideoStd_Type</a> <a class="el" href="struct_capture___attrs.html#75b44be66cfe05345a9aca3bfc4d076d">Capture_Attrs::videoStd</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
To force a certain video standard without auto detection, set this variable to something other than <a class="el" href="group__ti__sdo__dmai___video_std.html#gg516f1c2c17e3cf9bef416a6bbb8a928967c7473e7783791683178476d20a24c4">VideoStd_AUTO</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="4eb86cd8b67b2ba4394e99e2f84109de"></a><!-- doxytag: member="Capture_Attrs::decoderIdx" ref="4eb86cd8b67b2ba4394e99e2f84109de" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int <a class="el" href="struct_capture___attrs.html#4eb86cd8b67b2ba4394e99e2f84109de">Capture_Attrs::decoderIdx</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
To force a certain decoder on dm6467 instead of auto detecting which decoder supports your <a class="el" href="struct_capture___attrs.html#86073ec71e2dd56b968c7216a0e5e270" title="Which video input to use.">Capture_Attrs.videoInput</a>, set this to a value &gt; -1. See the VPIF device driver guide on which values apply (VIDIOC_S_STD ioctl). This is useful when auto detection doesn't work, e.g. when two EVM:s are interconnected. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The detected <a class="el" href="group__ti__sdo__dmai___capture.html#g0396f0332ca661d1894cc2b68a514114" title="Video capture inputs.">Capture_Input</a> on the decoder still needs to correspond to the <a class="el" href="struct_capture___attrs.html#86073ec71e2dd56b968c7216a0e5e270" title="Which video input to use.">Capture_Attrs.videoInput</a> set, or the function will fail. <p>
Only applicable for dm6467 Linux. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8889c59f3590235ca8a83c909d2fab8c"></a><!-- doxytag: member="Capture_Attrs::colorSpace" ref="8889c59f3590235ca8a83c909d2fab8c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ti__sdo__dmai___color_space.html#g1b6da3f159b6052d404f11cb010cb398">ColorSpace_Type</a> <a class="el" href="struct_capture___attrs.html#8889c59f3590235ca8a83c909d2fab8c">Capture_Attrs::colorSpace</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Output color format. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Only applicable for dm365 Linux. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bca75df189e0cdc448c9f89bd02aa74b"></a><!-- doxytag: member="Capture_Attrs::captureDimension" ref="bca75df189e0cdc448c9f89bd02aa74b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_buffer_gfx___dimensions.html">BufferGfx_Dimensions</a>* <a class="el" href="struct_capture___attrs.html#bca75df189e0cdc448c9f89bd02aa74b">Capture_Attrs::captureDimension</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Capture image size. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Only height and width elements are used. <p>
Set it to NULL, if resolution needs to be auto detected. <p>
Only applicable for dm365 Linux. </dd></dl>

</div>
</div><p>
<a class="anchor" name="78b419cc9d5e519b3c2c63af7a79ca14"></a><!-- doxytag: member="Capture_Attrs::onTheFly" ref="78b419cc9d5e519b3c2c63af7a79ca14" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool <a class="el" href="struct_capture___attrs.html#78b419cc9d5e519b3c2c63af7a79ca14">Capture_Attrs::onTheFly</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the resizer/previewer to "on the fly mode". In this mode the capture device is chained with previewer/resizer to resize and do chroma conversion on the fly. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Only applicable for dm365 Linux. <p>
If this flag is set for composite input, the captured frames will be de-interlaced automatically. <p>
If this flag is enabled the kernel command line parameter dm365_imp.oper_mode should be set to '1', otherwise '0'. </dd></dl>

</div>
</div><p>
<hr>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="_capture_8h-source.html">Capture.h</a></ul>
</div>
<hr size="1"><small>
Copyright  2011, Texas Instruments Incorporated</small>
</body>
</html>
